# K8s 
## 1、为什么需要K8s
### 1.1 单体应用和微服务
+ 在传统系统中，我们都是以单体应用的形式来开发的，单体应用由很多个组件组成，这些组件和模块紧密的耦合在一起，由于他们是在同一个操作系统中运行，所以开发、部署、管理他们必须是同一个进程进行，对单体应用来说，即时某个组件中一个小的修改，都需要重新部署应用，组件间缺乏模块的边界定义，相互依赖，系统复杂度提升，整体应用质量也急剧恶化。
+ 运行一个单体应用，通常需要一台能为整个应用提供足够资源的高性能服务器，为了应对不断增长的系统符合，我们需要通过增加CPU、内存或其他资源的方式对服务器进行垂直扩展。
+ 上述的问题迫使我们将一个复杂大型的单体应用拆分成可独立部署的微服务模块，下图是将一个庞大复杂的单体应用拆解成微服务，每个服务以独立的进程运行，服务之间通信可以通过HTTP同步协议、AMQP异步协议或者RPC远程成调用的方式进行通信，每个服务可以用最适合的开发语言来实现。![](https://wangzewei.oss-cn-beijing.aliyuncs.com/images/20220719085314.png)
### 1.2系统扩容
 + 在单体系统中的扩容是针对的整个系统，而棉线微服务的架构，我们的扩容只需要针对到具体的单个系统模块，这就意味着你可以选择仅扩容那些需要更多资源的服务，而保持其他服务在原来的规模上继续运行。
## 2、Docker和K8s
 + 本章将会介绍 Docker 和 Kubernetes 的一些基础知识，掌握 Docker 的组成结构以及 Docker 是怎么隔离容器、隔离硬件资源的，了解为什么用 Kubernetes，Kubernetes 的组成、结构等，我们会学习到很多 K8S 的术语。
 
    ### 2.1 Docker基础知识
    + 要使用K8s我们需要先学习Docker，因为在K8s早期是基于Docker容器运行的，很多文章也将Docker归为虚拟化，但是个人认为Docker并不是虚拟化的一个应用，Docker的底层他是通过Linux的两个机制实现的，第一个是Linux的命名空间，它的作用是使每个进程只看到他自己的系统视图（文件、网络接口、进程、主机名等），第二个是Linux控制组(cgroups)它的作用是用来限制进程能使用的资源量（CPU、内存、网络带宽等）。
    ### 2.2 容器化和虚拟机区别
    + 容器化与虚拟机比较，容器更加轻量级，它允许在相同的硬件上运行更多数量的组件，容器化是运行在同一个操作系统，而一个容器仅仅是运行在宿主机上被隔离的单个进程，容器化共享一组系统进程。而虚拟机的本质是需要运行一组系统进程，这就产生了除了组件进程消耗以外的额外计算资源损耗。容器化相比虚拟机更加轻量级。因为虚拟机额外的开销，可能会导致没有足够的资源给每个应用开一个虚拟机，最终我们会选择将多个应用程序分组放到每个虚拟机内，但是，当我们使用容器时，能够让每个应用有一个容器，最终的效果就是我们一个裸机可以运行更多的应用程序。Todo【缺图】
    ### 2.3 容器实现隔离机制介绍
    #### **Linux命名空间隔离进程**
      + 容器使用Linux命名空间隔离进程，每个Linux系统最初仅有一个命名空间，所有的系统资源都属于这一个命名空间。但是你可以额外的创建自己的命名空间，以及在他们之间组织协调各种资源，对于一个进程，可以在其中一个命名空间中运行它。该进程将只能看到同一个命名空间下的资源。会存在多种类型的多个命名空间，所以一个进程不单单仅属于某一个命名空间，而是属于每个类型的一个命名空间。
        + Mount
        + Process ID
        + NetWork
        + Inter-process communicaion (ipd)
        + UTS
        + User ID（User）
      + 每种命名空间被用来隔离一组特定的资源，例如：UTS 命名空间决定了运行在命名空间里的进程能看见哪些主机名和域名。通过分派两个不同的 UTS 命名空间给一对进程， 能使它们看见不同的本地主机名。通俗来说，这两个进程就好像正在两个不同的机器上运行一样（至少就主机名而言是这样的）。
    #### **进程可用资源限制**
      + 容器化的另一个隔离性是指限制容器使用的系统资源，例如限制（CPU、内存、网络带宽等），它是通过cgroups来实现的，cgroups是一个Linux内核功能，它被用来限制一个进程或一组进程的资源使用。使用量不能超过被分配的量。这种方式下，进程不能过分使用为其他进程保留的资源，这和进程运行在不同的机器上是类型的。