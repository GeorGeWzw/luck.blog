+ # 自动内存管理和CLR的理解
  [微软官方文档对内存管理和CLR的概述](https://docs.microsoft.com/zh-cn/dotnet/standard/managed-code)
  + ## 什么是托管代码？
    + 托管代码就是执行过程交由运行时管理的代码。 在这种情况下，相关的运行时称为公共语言运行时 (CLR)，不管使用的是哪种实现（例如 Mono、.NET Framework 或 .NET Core/.NET 5+）。 CLR 负责提取托管代码、将其编译成机器代码，然后执行它。 除此之外，运行时还提供多个重要服务，例如自动内存管理、安全边界、类型安全，等等。
    + 托管代码是使用可在 .NET 上运行的一种高级语言（例如 C#、Visual Basic、F# 等）编写的。 使用相应的编译器编译以这些语言编写的代码时，无法获得机器代码， 而是获得 中间语言 代码，然后运行时会对其进行编译并将其执行。
  + ## 什么是中间语言？
    +  中间语言是编译使用高级 .NET 语言编写的代码后获得的结果。对使用其中一种语言编写的代码进行编译后，即可获得 IL 所生成的二进制代码。
    +  从高级代码生成 IL 后，你很有可能想要运行它。 CLR 此时将接管工作，启动 实时 (JIT) 编译过程，或者将代码从 IL 实时 编译成可以真正在 CPU 上运行的机器代码。 这样，CLR 就能确切地知道代码的作用，并可以有效地 管理 代码。
    +  中间语言有时也称为公共中间语言 (CIL) 或 Microsoft 中间语言 (MSIL)。
  + ## 自动内存管理
    自动内存管理是公共语言运行时在托管执行过程中提供的服务之一。 公共语言运行时的垃圾回收器为应用程序管理内存的分配和释放。
    + ### 分配内存
      + 初始化新进程时，运行时会为进程保留一个连续的地址空间区域。 这个保留的地址空间被称为托管堆。 托管堆维护着一个指针，用它指向将在堆中分配的下一个对象的地址。
    + ### 释放内存
      + 垃圾回收器的优化引擎根据所执行的分配决定执行回收的最佳时间。 垃圾回收器在执行回收时，会释放应用程序不再使用的对象的内存。 它通过检查<font color=red>**应用程序的根来确定不再使用的对象**</font>。 每个应用程序都有一组根。 每个根或者引用托管堆中的对象，或者设置为空。
      + 为了改进性能，运行时为单独堆中的大型对象分配内存。 垃圾回收器会自动释放大型对象的内存。 但是，为了避免移动内存中的大型对象，不会压缩此内存。
  + ## 托管堆的级别和触发回收的时机
    为优化垃圾回收器的性能，将托管堆分为三代：第 0 代、第 1 代和第 2 代。运行时的垃圾回收器将新对象存储在第 0 级中。 在应用程序生存期的早期创建的对象如果未被回收，则被升级并存储在第 1 级和第 2 级中。 GC的回收机制是通过检查<font color=red>**扫描根引用和标记**</font>来进行确定回收的，这个根也称为<font color=red>**GC根**</font>。
    + ### 第 0 代执行回收的时机
      垃圾回收器在第 0 级托管堆已满时执行回收。 如果应用程序在第 0 级托管堆已满时尝试新建对象，垃圾回收器将会发现第 0 级托管堆中没有可分配给该对象的剩余地址空间。 垃圾回收器执行回收，尝试为对象释放第 0 级托管堆中的地址空间。 垃圾回收器从检查第 0 级托管堆中的对象（而不是托管堆中的所有对象）开始执行回收。
    + ### 第 1 代对象的创建和执行回收时机
      垃圾回收器执行第 0 级托管堆的回收后，会压缩可访问对象的内存，垃圾回收器升级这些对象，并考虑第 1 代托管堆的这一部分对象。 因为未被回收的对象往往具有较长的生存期，所以将它们升级至更高的级别很有意义。 因此，垃圾回收器在每次执行第 0 代托管堆的回收时，不必重新检查第 1 代和第 2 代托管堆中的对象。
    + ### 第 2 代 对象的创建和执行回收时机
      圾回收器执行第 1 代托管堆的回收后，会压缩可访问对象的内存，垃圾回收器升级这些对象，并考虑第 2 代托管堆的这一部分对象。大型对象堆上的对象（有时称为 第 3 代）也在第 2 代中收集。
    + ### 垃圾回收器的优化引擎会决定是否需要检查较旧的级别中的对象
      如果第 0 级托管堆的回收没有回收足够的内存，不能使应用程序成功完成创建新对象的尝试，垃圾回收器就会先执行第 1 级托管堆的回收，然后再执行第 2 级托管堆的回收。 如果这样仍不能回收足够的内存，垃圾回收器将执行第 2、1 和 0 级托管堆的回收。 每次回收后，垃圾回收器都会压缩第 0 级托管堆中的可访问对象并将它们升级至第 1 级托管堆。 第 1 级托管堆中未被回收的对象将会升级至第 2 级托管堆。 由于垃圾回收器只支持三个级别，因此第 2 级托管堆中未被回收的对象会继续保留在第 2 级托管堆中，直到在将来的回收中确定它们为无法访问为止。
    + ### 非托管资源的内存释放
      对于应用程序创建的大多数对象，可以依赖垃圾回收器自动执行必要的内存管理任务。 但是，非托管资源需要显式清除。 最常用的非托管资源类型是包装操作系统资源的对象，例如，文件句柄、窗口句柄或网络连接。 虽然垃圾回收器可以跟踪封装非托管资源的托管对象的生存期，但却无法具体了解如何清理资源。 创建封装非托管资源的对象时，建议在公共 Dispose 方法中提供必要的代码以清理非托管资源。 通过提供 Dispose 方法，对象的用户可以在使用完对象后显式释放其内存。
  + ## 85kb的划分是指浅层对象还是深层对象？
    假如我们现在有一个对象Order对象如下定义，那么我们的order是应该在第0代还是在大对象堆呢？
    答案是在第0代，但是OrderItems是在大对象堆中的，所以85kb的只计算了浅层对象的大小，不计算对象的深层大小。
    ``` C#
    public class Progarm{
      public static void main(){
        var order=new Order();// 0代
      }
    }


    public class Order {
      public OrderItem OrderItems{get private set;}=[5000];//>85kb字节 3代
    }

    public class OrderItem{
      public string ProductId{get; private set;}
    }
    ```
  + 
  + ## 垃圾回收
    + ### 基础
      + #### 优点
        + 开发人员不必手动释放内存。
        + 有效分配托管堆上的对象。
        + 回收不再使用的对象，清除它们的内存，并保留内存以用于将来分配。 托管对象会自动获取干净的内容来开始，因此，它们的构造函数不必对每个数据字段进行初始化。
        + 通过确保对象不能使用另一个对象的内容来提供内存安全。
    + ### 垃圾回收的条件
      + 系统具有低的物理内存。 这是通过 OS 的内存不足通知或主机指示的内存不足检测出来。
      + 由托管堆上已分配的对象使用的内存超出了可接受的阈值。 随着进程的运行，此阈值会不断地进行调整。
      + 调用GC.Collect方法。 几乎在所有情况下，你都不必调用此方法，因为垃圾回收器会持续运行。 此方法主要用于特殊情况和测试。
  + ## GC执行的流程？
    
  + ## GC如何表示对象需要回收？
  + ## GC/IDisposable/析构函数三者的关系？
  + ## 内存溢出如何发现和解决？
  + 